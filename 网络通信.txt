----------------------------------------------------------------------------------------------------------

网络七层协议 OSI（Open System Interconnection）开放式系统互联参考模型 
定义：一个定义的非常好的协议规范
	物理层；
	数据链路层；
	网络层：提供最基本的端到端的数据传送服务：IP；
	传输层：总体的数据传输和数据控制：UDP，TCP；
	会话层：定义了如何开始、控制和结束一个会话；
	表示层：定义数据格式及加密；
	应用层：定义了运行在不同端系统上的应用程序进程之间的通信：FTP，Telnet，SMTP，HTTP，RIP，NFS，DNS；

	优点：
	1、人们可以很容易的讨论和学习协议的规范细节。
	2、层间的标准接口方便了工程模块化。
	3、创建了一个更好的互连环境。
	4、降低了复杂度，使程序更容易修改，产品开发的速度更快。
	5、每层利用紧邻的下层服务，更容易记住各层的功能。

----------------------------------------------------------------------------------------------------------

HTTP请求过程：
	1、查询缓存、DNS域名解析、获取IP地址：
		浏览器缓存-->系统缓存-->hosts文件-->服务商的DNS服务器-->根域名服务器；
	2、封装HTTP请求数据包、封装TCP请求数据包、与IP地址对应的服务器建立TCP连接、TCP的三次握手：
		第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）；
		第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
		第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手；
	3、客户端发送HTTP请求：
	4、服务器响应HTTP请求：
	5、客户端得到HTML代码、浏览器解析HTML代码、请求HTML代码中的资源：
	6、浏览器渲染页面呈现给用户：

----------------------------------------------------------------------------------------------------------

常用状态码：
	200：OK（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
	301：Moved Permanently（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置。
	302：Found（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
	304：Not Modified（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。
	400：Bad Request（错误请求） 服务器不理解请求的语法。
	401：Unauthorized（未授权） 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应。
	403：Forbidden（禁止） 服务器拒绝请求。
	404：Not Found（未找到） 服务器找不到请求的网页。
	500：Internal Server Error（服务器内部错误） 服务器遇到错误，无法完成请求。
	502：Bad Gateway（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
	503：Service Unavailable（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
	504：Gateway Timeout（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。

----------------------------------------------------------------------------------------------------------

HTTP请求方法：
	GET：请求指定的页面信息，并返回实体主体。
	POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立或已有资源的修改。
	HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
	PUT：从客户端向服务器传送的数据取代指定的文档的内容。
	DELETE：请求服务器删除指定的页面。
	CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
	OPTIONS：允许客户端查看服务器的性能。
	TRACE：回显服务器收到的请求，主要用于测试或诊断。
	PATCH：实体中包含一个表，表中说明与该URI所表示的原内容的区别。
	MOVE：请求服务器将指定的页面移至另一个网络地址。
	COPY：请求服务器将指定的页面拷贝至另一个网络地址。
	LINK：请求服务器建立链接关系。
	UNLINK：断开链接关系。
	WRAPPED：允许客户端发送经过封装的请求。
	Extension-mothed：在不改动协议的前提下，可增加另外的方法。

	GET和POST区别：
	1、在客户端，GET方式在通过URL提交数据时，数据在URL中可以看得到；POST方式，数据放在HTTP包的body中。
	2、GET方式提交的数据大小有限制，而POST没有此限制。
	3、安全性问题。正如（1）中提到使用GET的时候，参数会显示在地址栏，而POST不会。所以，非敏感数据使用GET，敏感数据使用POST。
	4、服务器取值方式不一样。GET方式取值，如php可以使用$_GET来取得变量的值，而POST方式通过$_POST来获取变量的值。

	注意：在HTML文档中，书写get和post，大小写都可以，但在HTTP协议中的GET和POST只能是大写形式。

----------------------------------------------------------------------------------------------------------

IP：IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP，用来在Internet上标识这台计算机。
	IP负责在Internet上发送和接受数据包。IP层接受更低层发来的数据包并发送至更高层，TCP或UDP；相反，IP层也接受更高层发来的数据包并发送至更低层。
	IP数据包不可靠，因为IP没有做任何事情来确认数据包是否按顺序发送的或者有没有被损坏。
	IP数据包中含有源地址和目的地址。
	属于网络层。

TCP：（Transmission Control Protocol 传输控制协议）。
	是一种面向连接的、可靠的、基于字节流的传输层通信协议。
	属于传输层。
	基于TCP的协议有：HTTP/HTTPS，Telnet，FTP，SMTP。

UDP：（User Datagram Protocol 用户数据报协议）。
	是一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。
	属于传输层。
	基于UDP的协议有：DHCP，DNS，SNMP，TFTP，BOOTP。

TCP/UDP：TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议。其中TCP提供IP环境下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。通俗说，它是事先为所发送的数据开辟出连接好的通道，然后再进行数据发送；而UDP则不为IP提供可靠性、流控或差错恢复功能。一般来说，TCP对应的是可靠性要求高的应用，而UDP对应的则是可靠性要求低、传输经济的应用。TCP支持的应用协议主要有：Telnet、FTP、SMTP等；UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等。
		“面向连接”就是在正式通信前必须要与对方建立起连接。例如：打电话；
		“面向非连接”就是在正式通信前不必与对方先建立连接，不管对方状态就直接发送。例如：发短信；
	区别：
		TCP：面向连接、可靠的、传输大量的数据、慢；
		UDP：面向非连接、不可靠的、传输少量数据、快；
	总结：
		TCP是面向连接的、可靠的、有序的、速度慢的协议；UDP是无连接的、不可靠的、无序的、速度快的协议。
		TCP开销比UDP大，TCP头部需要20字节，UDP头部只要8个字节。
		TCP无界有拥塞控制，UDP有界无拥塞控制。
	概念：
		拥塞控制：防止过多的数据注入到网络中。
		流量控制：指点对点通信量的控制。
		TCP滑动窗口机制：
			1、首先是AB之间三次握手建立TCP连接。在报文的交互过程中，A将自己的缓冲区大小（窗口大小）3发送给B，B同理，这样双方就知道了对端的窗口大小。
			2、A开始发送数据，A连续发送3个单位的数据，因为他知道B的缓冲区大小。在这一波数据发送完后，A就不能再发了，需等待B的确认。
			3、A发送过来的数据逐渐将缓冲区填满。
			4、这时候缓冲区中的一个报文被进程读取，缓冲区有了一个空位，于是B向A发送一个ACK，这个报文中指示窗口大小为1。
			5、A收到B发过来的ACK消息，并且知道B将窗口大小调整为1，因此他只发送了一个单位的数据并且等待B的下一个确认报文。
			如此反复。

TCP/IP：是一个协议组，由TCP和IP一起协同工作，是上下层次的关系，可分为三个层次：网络层、传输层和应用层。主要负责数据在Internet上的通信。
	工作原理：
		1、在源主机上应用层将一串字节流传给传输层。
		2、传输层将字节流分成TCP段，加上TCP包头交给网络(IP)层。
		3、IP层生成一个包，将TCP段放入其数据域，并加上源和目的主机的IP包交给数据链路层。
		4、数据链路层在其帧的数据部分装IP包，发往目的主机或IP路由器。
		5、在目的主机，数据链路层将数据链路层帧头去掉，将IP包交给网络层。
		6、IP层检查IP包头，如果包头中的校验和与计算出来的不一致，则丢弃该包。
		7、如果校验一致，IP层去掉IP头，将TCP段交给TCP层，TCP层检查顺序号来判断是否为正确的TCP段。
		8、TCP层为TCP包头计算TCP头和数据。如果不对，TCP层丢弃这个包，若对，则向源主机发送确认。
		9、在目的主机，TCP层去掉TCP头，将字节流传给应用程序。
		10、于是目的主机收到了源主机发来的字节流，就像直接从源主机发来的一样。

HTTP：（HyperText Transfer Protocol）超文本传输协议
	是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。
	基于TCP/IP协议之上。
	默认端口号是80。
	是应用层的协议。
	HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。
	HTTP是一个无连接状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息，HTTP遵循请求(Request)/应答(Response)模型。

HTTP、TCP、UDP：都是通信协议，也就是通信时所遵守的规则，只有双方按照这个规则“说话”，对方才能理解或为之服务。
	关系:
		TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。
		在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
		在传输层中有TCP协议与UDP协议。
		在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。
		因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。

HTTPS：（Hyper Text Transfer Protocol over Secure Socket Layer）安全超文本传输协议
	是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL。其所用的端口号是443。

HTTPS通信过程：
			1、SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的TCP连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
			2、客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。
			3、如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。

SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。
TLS：（Transport Layer Security，传输层安全协议），用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。
备注：SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。

SSL工作原理：
　　① 浏览器发送一个连接请求给安全服务器。
　　② 服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。
　　③ 客户浏览器检查服务器送过来的证书是否是由自己信赖的 CA 中心所签发的。如果是，就继续执行协议；如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。
　　④ 接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。
　　⑤ 服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接；如果通过验证，服务器获得用户的公钥。
　　⑥ 客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。
　　⑦ 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。
　　⑧ 浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。
　　⑨ 服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。
　　⑩ 服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。

对称加密/非对称加密：
	对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES，RC5，3DES等；
		对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。解决这个问题的方案非对称秘钥。
	非对称加密：使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。
		这种密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

HTTP/HTTPS区别：
		1.HTTP的URL以http://开头，而HTTPS的URL以https://开头
		2.HTTP是不安全的，而HTTPS是安全的
		3.HTTP标准端口是80，而HTTPS的标准端口是443
		4.在OSI网络模型中，HTTP工作于应用层，而HTTPS工作在传输层
		5.HTTP无法加密，而HTTPS对传输的数据进行加密
		6.HTTP无需证书，而HTTPS需要CA机构颁发的SSL证书

HTTP详解：
	URI：Uniform Resource Identifier，统一资源标识符
	URL：Uniform Resource Locator，统一资源定位符
	URN：Uniform Resource Name，统一资源名称

	请求格式：
		请求行：请求方法 URI 协议/版本
		请求头：头部信息
		请求正文：发送给服务器的query信息
		注意：当使用GET方法时，body是为空的（GET只能读取服务器上的信息，POST能写入）

	响应格式：
		状态行：协议/版本 状态码 状态描述
		响应头：头部信息
		响应正文：返回请求的资源内容

	请求头：
		Cache 头域
			If-Modified-Since
			用法：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT
			把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。

			If-None-Match
			用法：If-None-Match: "03f2b33c0bfcc1:0"
			If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能

			Pragma：Pragma: no-cache
			Pargma只有一个用法，例如：Pragma: no-cache
			作用：防止页面被缓存，在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样

			Cache-Control
			用法：
			Cache-Control:Public 可以被任何缓存所缓存（）
			Cache-Control:Private 内容只缓存到私有缓存中
			Cache-Control:no-cache 所有内容都不会被缓存
			作用：用来指定Response-Request遵循的缓存机制

		Client 头域
			Accept
			用法：Accept: */*，Accept: text/html
			作用：浏览器端可以接受的媒体类型
			Accept: */* 代表浏览器可以处理所有回发的类型，(一般浏览器发给服务器都是发这个）
			Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html ；如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable) 

			Accept-Encoding
			用法：Accept-Encoding: gzip, deflate
			作用：浏览器申明自己接收的文件编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是指字符编码）

			Accept-Language
			用法：Accept-Language: en-us
			作用：浏览器申明自己接收的语言。
			语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；

			User-Agent
			用法： User-Agent: Mozilla/4.0......
			作用：告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本.

			Accept-Charset
			用法：Accept-Charset：utf-8
			作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案） 

		Cookie/Login 头域
			Cookie
			Cookie: bdshare_firstime=1439081296143; ASP.NET_SessionId=rcqayd4ufldcke0wkbm1vhxb; pgv_pvi=7361416192; pgv_si=s6686106624; ce.sysu.edu.cn80.ASPXAUTH=9E099592DD5A414BEECD8CF43CFC71664
			作用：最重要的header, 将cookie的值发送给HTTP服务器

		Entity 头域
			Content-Length
			用法：Content-Length: 38
			作用：发送给HTTP服务器数据的长度。

			Content-Type
			用法：Content-Type: application/x-www-form-urlencoded
			不常出现，一般出现在response头部，用于指定数据文件类型

		Miscellaneous 头域
			Referer
			用法：Referer: http://ce.sysu.edu.cn/hope/
			作用：提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。

		Transport 头域
			Connection
			Connection: keep-alive：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
			Connection: close：代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接

			Host
			用法：Host: ce.sysu.edu.cn
			作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号（默认80），它通常从HTTP URL中提取出来的

	响应头：
		Cache 头域
			Date
			用法：Date: Sat, 11 Feb 2012 11:35:14 GMT
			作用: 生成消息的具体时间和日期

			Expires
			用法：Expires: Tue, 08 Feb 2022 11:35:14 GMT
			作用: 浏览器会在指定过期时间内使用本地缓存

			Vary
			用法：Vary: Accept-Encoding

		Cookie/Login 头域
			P3P
			用法：
			P3P: CP=CURa ADMa DEVa PSAo PSDo OUR BUS UNI PUR INT DEM STA PRE COM NAV OTC NOI DSP COR
			作用: 用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题

			Set-Cookie 
			用法： 
			Set-Cookie: sc=4c31523a; path=/; domain=.acookie.taobao.com
			作用：非常重要的header, 用于把cookie 发送到客户端浏览器， 每一个写入cookie都会生成一个Set-Cookie.

		Entity 头域
			ETag
			用法：ETag: "03f2b33c0bfcc1:0"
			作用: 和request header的If-None-Match 配合使用

			Last-Modified
			用法：Last-Modified: Wed, 21 Dec 2011 09:09:10 GMT
			作用：用于指示资源的最后修改日期和时间。（实例请看上节的If-Modified-Since的实例）

			Content-Type
			用法：
			Content-Type: text/html; charset=utf-8
			Content-Type: text/html; charset=GB2312
			Content-Type: image/jpeg
			作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集

			Content-Encoding
			用法：Content-Encoding：gzip
			作用：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。

			Content-Language
			用法：Content-Language:da
			WEB服务器告诉浏览器自己响应的对象的语言

		Miscellaneous 头域
			Server
			用法：Server: Microsoft-IIS/7.5
			作用：指明HTTP服务器的软件信息

			X-AspNet-Version
			用法：X-AspNet-Version: 4.0.30319
			作用：如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本

			X-Powered-By
			用法：X-Powered-By: ASP.NET
			作用：表示网站是用什么技术开发的

		Transport 头域
			Connection
			用法与作用：
			Connection: keep-alive：当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
			Connection: close：代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接

		Location 头域
			Location
			用法：Location：http://ce.sysu.edu.cn/hope/
			作用：用于重定向一个新的位置，包含新的URL地址

Socket：是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API）。
		通过Socket，我们才能使用TCP/IP协议。
		实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。
		所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象。
		从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。